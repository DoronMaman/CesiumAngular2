{"version":3,"sources":["coordinate-converter.service.ts"],"names":[],"mappings":"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","file":"coordinate-converter.service.js","sourceRoot":"","sourcesContent":["import { Injectable, Optional } from '@angular/core';\r\nimport { CesiumService } from '../cesium/cesium.service';\r\nimport * as geodesy from 'geodesy';\r\n\r\nconst UTM = geodesy.Utm;\r\nconst LatLonEllipsoidal = geodesy.LatLonEllipsoidal;\r\n\r\n/**\r\n *  Given different types of coordinates, we provide you a service converting those types to the most common other types.\r\n *  We are using the geodesy implementation of UTM conversion. see: https://github.com/chrisveness/geodesy.\r\n *\r\n * @example\r\n * import { Component, OnInit } from '@angular/core';\r\n * import { CoordinateConverter } from 'angular2-cesium';\r\n *\r\n * @Component({\r\n * \t\tselector:'my-component',\r\n * \t\ttemplate:'<div>{{showCartographic}}</div>',\r\n * \t\tproviders:[CoordinateConverter]\r\n * })\r\n * export class MyComponent implements OnInit {\r\n * \t\tshowCartographic;\r\n *\r\n * \t\tconstructor(private coordinateConverter:CoordinateConverter){\r\n * \t\t}\r\n *\r\n * \t\tngOnInit(){\r\n * \t\t\tthis.showCartographic = this.coordinateConverter.degreesToCartographic(5, 5, 5);\r\n *  }\r\n * }\r\n *\r\n */\r\n\r\nexport class CoordinateConverter {\r\n  constructor( private cesiumService?: CesiumService) {\r\n  }\r\n\r\n  screenToCartesian3(screenPos: {x: number, y: number}, addMapCanvansBoundsToPos?: boolean) {\r\n    if (!this.cesiumService) {\r\n      throw new Error('ANGULAR2-CESIUM - Cesium service should be provided in order to do screen position calculations');\r\n    }\r\n    else {\r\n      const screenPosition = {...screenPos};\r\n      if (addMapCanvansBoundsToPos) {\r\n        const mapBounds = this.cesiumService.getViewer().canvas.getBoundingClientRect();\r\n\t\t\t\tscreenPosition.x += mapBounds.left;\r\n\t\t\t\tscreenPosition.y += mapBounds.top;\r\n      }\r\n      \r\n      const camera = this.cesiumService.getViewer().camera;\r\n      return camera.pickEllipsoid(screenPosition);\r\n    }\r\n  }\r\n\r\n  screenToCartographic(screenPos: {x: number, y: number}, ellipsoid?: any) {\r\n    return this.cartesian3ToCartographic(this.screenToCartesian3(screenPos), ellipsoid);\r\n  }\r\n\r\n  cartesian3ToCartographic(cartesian, ellipsoid?: any) {\r\n    return Cesium.Cartographic.fromCartesian(cartesian, ellipsoid);\r\n  }\r\n\r\n  degreesToCartographic(longitude: number, latitude: number, height?: number) {\r\n    return Cesium.Cartographic.fromDegrees(longitude, latitude, height);\r\n  }\r\n\r\n  radiansToCartographic(longitude: number, latitude: number, height?: number) {\r\n    return Cesium.Cartographic.fromRadians(longitude, latitude, height);\r\n  }\r\n\r\n  degreesToUTM(longitude: number, latitude: number, height?: number) {\r\n    return new LatLonEllipsoidal(latitude, longitude, undefined, height).toUtm();\r\n  }\r\n\r\n  UTMToDegrees(zone: number, hemisphere: string, easting: number, northing: number) {\r\n    return this.geodesyToCesiumObject(new UTM(zone, hemisphere, easting, northing).toLatLonE());\r\n  }\r\n\r\n  private geodesyToCesiumObject(geodesyRadians) {\r\n    return {\r\n      longitude: geodesyRadians.lon,\r\n      latitude: geodesyRadians.lat,\r\n      height: geodesyRadians.height ? geodesyRadians.height : 0\r\n    };\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: CesiumService, decorators: [{ type: Optional }, ]},\n];\n}\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}